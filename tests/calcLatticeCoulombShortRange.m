function W = calcLatticeCoulombShortRange(meshstruct,k,nmax,E)
%CALL:      W = calcLatticeCoulombOptimized(meshstruct,k,nmax,E)
%DESCRIPTION: Calculates the lattice sum
%   WE = ( sum_(R=Rall) exp(i*k*R)/|r-R| )*exp(-i*k*dr)
%by means of the Ewald summation technique [as described in e.g. Gallinet
%et al, JOSA A 27, 2261 (2010)] of the effective Coulomb potential in a
%periodic structure characterized by 2D lattice vectors R{1} and R{2} for a
%nonzero momentum k for seperations dr = r - r', for points r and r'
%equaling those specified in meshstruct.
%INPUT: The following variable form is expected:
%       meshstruct : structure generated by geomLatticeInclusion(..)
%       k : momentum as [1 x 2] row vector
%       nmax : positive integer (cutoff in lattice summation)
%              [can be given as a 2-element vector; then first element
%              indicates number of terms (in each dir.) in R-sum, and
%              second element indicates number of terms (in each dir.) in
%              G-sum]
%       E : Ewald splitting parameter [default = sqrt(pi/A_uc)]
%NOTE: This is a highly optimized equivalent of calcLatticeCoulomb, which 
%is roughly 40 - 60% faster.
%
%SHORT RANGE INTERACTION ONLY - JUST FOR TEST PURPOSES!

fprintf('Calculates the SHORT-RANGE ONLY (i.e. lattice without long range) Coulomb matrix via summation in 16 subtriangle elements V\n')

%Unwrapping the necessary elements of the blochmesh structure
p = meshstruct.p;
t = meshstruct.t;
areas = meshstruct.area;
R = meshstruct.R;
remesh = meshstruct.remesh;

%Number of vertices and elements (triangles)
Nvert = size(p,1);
Ntri = size(t,1);

%If unspecified, choose default value
if ~exist('nmax','var') || isempty(nmax);
    nmax = 2 + (norm(k) == 0)*2;
end
if numel(nmax) == 1 %Equal number of each direct/reciprocal lat. vec.
    loopR1 = -nmax:nmax; loopR2 = loopR1;  
elseif numel(nmax) == 2; %Different number of direct/reciprocal lat. vec.
    loopR1 = -nmax(1):nmax(1);   loopR2 = loopR1; 
elseif all(size(nmax) == [2,2]) %Distinction in numbers of each direct/reciprocal lat. vec. along each direction
    loopR1 = -nmax(1,1):nmax(1,1);   loopR2 = -nmax(1,2):nmax(1,2);  
end
numRvec = numel(loopR1)*numel(loopR2); 
fprintf('   Ewald summation parameters | %g by %g terms in R-sum\n',numel(loopR1),numel(loopR2))


%The fundamental reciprocal lattice vectors and unit cell area
[~,A_uc] = calcReciprocal(R); 

%Direct and reciprocal lattice vectors  needed in the Ewald scheme are
%computed once and for all here
Rnm(:,1) = reshape(bsxfun(@plus,loopR1'*R{1}(1),loopR2*R{2}(1)),numRvec,1);
Rnm(:,2) = reshape(bsxfun(@plus,loopR1'*R{1}(2),loopR2*R{2}(2)),numRvec,1);

%The optimal integral splitting parameter in the Ewald scheme (as
%suggested by Gallinet et al.) [default value]
if nargin < 4 || isempty(E)
    E = sqrt(pi/A_uc);
end

%Reocurring exponential elements needed in the Ewald scheme
expiRnmk = exp(1i*(k(1)*Rnm(:,1) + k(2)*Rnm(:,2)));
expikr =   exp(-1i*( k(1)*p(:,1)+k(2)*p(:,2) ) );

%Gaussian quadrature weights
GaussQuadMat = [ 10, 7, 8, 7, 4, 5, 4, 5, 4,  1, 2, 1, 2, 1, 2,  1 ; ...
                  1, 4, 2, 1, 7, 5, 4, 2, 1, 10, 8, 7, 5, 4, 2,  1 ; ...
                  1, 1, 2, 4, 1, 2, 4, 5, 7,  1, 2, 4, 5, 7, 8, 10 ];

%Preallocation
W = zeros(Nvert,Nvert); 

%Construct the total Coulomb matrix by summing over contributions from all
%triangle elements
timeV = tic;
for j = 1:Ntri
    if mod(j,250) == 0; fprintf('   j-loop:   %g/%g (%.1f min/%.1f min)\n',j,Ntri,toc(timeV)/60,toc(timeV)/60/(j/Ntri)); end
    s = areas(j);
    l = remesh.t(j,1); m = remesh.t(j,2); n = remesh.t(j,3);    %This must be the remeshed positions, in order to
    rl = remesh.p(l,:); rm = remesh.p(m,:); rn = remesh.p(n,:); %get the subtriangle positions correct (they are NOT on the edge)
    
    cpnt = calcQuadraturePoints(rl,rm,rn); %Center points for 16 subtriangles in the j'th triangle
    
    %Evaluates the effective (lattice-summed) Coulomb potential for these
    %vectors for the specified lattice R at momentum k (via funW1 & funW2)
    %Each element is finally the summation of contributions from all sub-
    %triangles, added into the total Coulomb matrix at the vertex sites
    W(:,t(j,:)) = W(:,t(j,:)) + ( GaussQuadMat * funW2(p,cpnt,k,Rnm,expiRnmk,expikr,E)  ).'*s;
end
W = W/192; %Normalize by (straggling numerical factors)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%     SUBFUNTIONS     %%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function W2 = funW2(r,rp,k,Rnm,expiRnmk,expikr,E)

%Number of points in r and rp (assumed in column form)
numr = size(r,1); numrp = size(rp,1);
%Calculate W2 by vector operations only (the following two calculations, i.e.
%absdrRnm and W, take >95% of all evaluation-time for calcLatticeCoulombOptimized!)
absdrRnm = pdist2([reshape(bsxfun(@minus, r(:,1).', rp(:,1)),numrp*numr,1),... %Calculates all distances between (r, rp), and Rnm 
                   reshape(bsxfun(@minus, r(:,2).', rp(:,2)),numrp*numr,1)],...%This implementation is faster than a sqrt-implementation
                   Rnm);                                                       %because it utilizes a .mex function (so it is C I guess)
W2 = (erfc(absdrRnm*E)./absdrRnm) * expiRnmk; %The matrix multiplication takes care of a summation-type operation
prefactor = bsxfun(@times, expikr.', exp(1i*(k(1)*rp(:,1) + k(2)*rp(:,2))));
W2 =  prefactor(:).*W2;

%Reshape to the size we would get from bsxfun'ing r.' with rp
W2 = reshape(W2, [numrp, numr]);